一、模型-视图-控制器（MVC）体系结构模式：
1、模型M：表示应用数据的类。模型类使用验证逻辑来对该数据强制实施业务规则。通常，模型对象检索模型状态并将其存储在数据库中。
---描述正在使用的数据以及业务逻辑的一组类
2、视图V：视图是显示应用用户界面UI的组件。此UI通常会显示模型数据。
---定义应用程序的 UI 将如何显示。这是一个纯粹的 HTML，它决定了 UI 的外观
3、控制器C：处理浏览器请求的类。它们检索模型数据并调用返回响应的视图模板。
---一组用来处理来自用户的交流通讯，整体应用程序流和特定于应用程序的逻辑的类
在MVC应用中，视图仅显示信息；控制器处理并响应用户输入和交互。如，控制器处理路由数据和查新字符串值，并将这些值传递给模型。该模型可使用这些值查询数据库。
MVC模式可帮助创建分割不同应用特性（输入逻辑、业务逻辑和UI逻辑）的应用，同时让这些元素之间实现松散耦合。该模式可指定应用中每种逻辑的位置。UI逻辑位于视图中。输入逻辑位于控制器中。业务逻辑位于模型中。这种隔离有助于控制构建应用时的复杂程度，因为它可用于一次处理一个实现特性，而不影响其他特性的代码。如，处理视图代码时不必依赖业务逻辑代码。

二、MVC根据入站URL调用控制器类（及其中的操作方法）。
MVC默认URL留言逻辑格式：/[Controller]/[ActionName]/[Parameters]  详情请看Startup.cs文件的Configure方法

三、将数据从控制器传递给视图
1、控制器操作会被调用以响应传入的URL请求。
控制器类是编写处理传入浏览器请求的代码的地方。
控制器从数据源检索数据，并决定将哪些类型的响应发送回浏览器。
可以从控制器使用视图模板来生成并格式化对浏览器的HTML响应。
2、控制器负责提供所需的数据，是视图模板能够呈现响应。最佳做法：视图模板不应该直接执行业务逻辑或与数据库进行交互。相反，视图模板应仅使用由控制器提供给它的数据。保持此“分离关注点”有助于保持代码干净以及可测试性和可维护性

四、DRY原则
1、MVC的设计原则之一是DRY（不要自我重复）。
2、ASP.NET Core MVC支持仅指定一次功能或行为，然后使它应用到中个应用中，使之减少所需编写的代码量，并使编写的代码更少出错，更易于测试和维护。
3、可以在一个位置（模型类中）以声明方式指定验证规则，并且在应用中的所有位置强制执行（详情可以参见UsersViewModel.cs模型）
4、让ASP.NET Core强制自动执行验证规则有助于提升应用的可靠性。同时它能确保你无法忘记验证某些内容，并防止你无意中将错误数据导入数据库

五、CRUD（增加create、读取retrieve、更新update、删除delete）
CRUD操作方法和视图的自动创建被称为基架。
基架与代码生成不同，基架的代码是一个起点，可以修改基架以满足自己需求，而你通常无需修改生成的代码。 当你需要自定义生成代码时，可使用一部分类或需求发生变化时重新生成代码。

六、MVC 背后的理念
现在，我们来了解下 MVC 背后的理念

使用 MVC 设计模式，我们将拥有一个称为视图的组件，它独自负责呈现该用户界面，不管它是 HTML 还是桌面应用程序上的 UI 小部件

该视图与模型通讯，模型包含视图需要显示的所有数据

Web 应用程序中，视图可能根本没有任何关联的代码， 它可能只是 HTML，然后是从模型中获取数据片段的表达式，并将它们插入到我们在视图中构建的 HTML 模板中的正确位置

控制器用于组织一切。当一个 HTTP 请求到达 MVC 应用程序时，请求会被路由到一个控制器，然后由控制器来与数据库，文件系统或模型交谈


七、ASP.NET Core 中的 MVC
ASP.NET Core 也使用了 MVC 设计模式，当控制器接收到一个 HTTP 请求时， 控制器必须弄清楚如何将这些信息放在一起来响应这个请求。

比如用户想要浏览应用程序的 /books 页面，那么，控制器需要将这些信息放在一起以显示书籍列表。

在这种情况下，控制器将建立一个模型：
――》（GET /books）Controller――》（Builds）Model――》（Renders）View――》(HTML)

模型不知道也不必知道有关 HTTP 请求或控制器的任何信息
模型仅负责保存用户想要查看的书籍信息以及与该书目列表相关的任何逻辑
模型可能仅仅是我们可以使用的另一个 C# 类，如果复杂一点，则可能有多个类
一旦将模型放在一起，控制器就可以选择一个视图来渲染模型
该视图将使用模型中的信息，如所有书籍和每本书名等，并使用该信息构建 HTML 页面
然后，该 HTML 将作为 HTTP 响应发送回客户端，并完成整个 HTTP 请求和响应事务
这些都是 MVC 设计模式的基础，这种模式背后的理念是保持关注的分离。

控制器只负责接受请求并建立模型。 是将我们需要的逻辑和数据带入视图的模型。 然后视图只负责将该模型转换为 HTML

MVC 框架中，我们有三个组件，每个组件都专注于特定部分的工作。 为了使所有这些工作，我们需要找到一种方法将这些 HTTP 请求发送到正确的控制器。 在 ASP.NET Core MVC 中，这个过程称为路由。 路由是指导 HTTP 请求到控制器的过程

在 Mvc 模式中，控制器决定接下来要做什么，返回一个字符串或 HTML 或返回可能被序列化为 JSON 等的模型对象

Mvc 中的控制器需要做的就是做出决定，但控制器不必直接在响应中写入决策结果。 它只需要返回结果，然后框架会使用这些结果并理解如何将结果转换为可通过 HTTP 发回的内容

八、ASP.NET Core动作结果
在 MVC 框架中，ObjectResult 是特殊的，因为当我们返回一个 ObjectResult 时，MVC 框架将访问这个对象。并将这个对象做一些转换，然后作为 HTTP 响应返回给客户端

在转换 ObjectResult 对象时，它可能被序列化为 XML 或 JSON 或其它格式， 至于什么格式，由应用程序启动时向 MVC 提供的配置信息决定。如果我们没有显式的配置任何东西，那么将会使用 JSON 作为默认格式

九、V
ASP.NET Core MVC 应用程序中，没有任何内容像页面，并且在 URL 中指定路径时， 它也不包含与页面直接对应的任何内容。 ASP.NET Core MVC 应用程序中最接近页面的东西被称为视图

页面就是一个服务器端返回的数据，但这个数据并不是直接存在的，而是由控制器、模型、视图三大部分相作用的结果。

这是因为，也是你知道的，在 ASP.NET MVC 应用程序中，所有传入的请求均由控制器处理，并将这些请求映射到控制器相应的方法上

控制器方法可能会返回一个视图，也可能执行其它类型的操作，例如重定向到另一个控制器方法上

如果使用 MVC 框架，最流行的创建 HTML 的方法是使用 ASP.NET MVC 的 Razor 视图引擎

为了使用 Razor 视图引擎，一个控制器方法将产生一个 ViewResult 对象，而一个 ViewResult 可以携带我们想要使用的 Razor 视图的名称

Controller―decide―》ViewResult―do―》<HTML>

该视图是文件系统上的文件，且 ViewResult 还可以将一个模型对象带到视图中，且视图可以在创建 HTML 时使用该模型对象

当 MVC 框架看到控制器方法返回一个 ViewResult 时，框架将在文件系统上查找对应的视图，执行视图生成 HTML，然后框架会将这个 HTML 作为响应发送回客户端

当我们在 Razor 视图中使用 @ 符号时，Razor 视图引擎会将我们输入的任何内容视为 C# 表达式
Razor 视图包含一些我们可以在 C# 表达式中访问的内置成员，最重要的成员之一就是模型 ( Model )
但我们使用 @Model 时，意思就是使用从控制器传入视图的模型对象

十、